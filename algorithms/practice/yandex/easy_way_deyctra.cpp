/*
¬ каждой клетке пр€моугольной таблицы NxM записано некоторое число. »значально игрок находитс€ в левой верхней клетке. 
«а один ход ему разрешаетс€ перемещатьс€ в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещатьс€ запрещено).
ѕри проходе через клетку с игрока берут столько килограммов еды, какое число записано в этой клетке 
(еду берут также за первую и последнюю клетки его пути).

“ребуетс€ найти минимальный вес еды в килограммах, отдав которую игрок может попасть в правый нижний угол.
*/

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int INF = 1e9; // Ѕесконечность (достаточно большое число)

int main() {
    int N, M;
    cin >> N >> M;

    vector<vector<int>> value(N, vector<int>(M));

    // ¬вод значений в клетки
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> value[i][j];
        }
    }

    // —оздаем массив дл€ хранени€ минимальных рассто€ний
    vector<vector<int>> dist(N, vector<int>(M, INF));

    // —оздаем очередь с приоритетом (пара: (рассто€ние, координаты клетки))
    priority_queue<pair<int, pair<int, int>>> pq;

    dist[0][0] = value[0][0]; // Ќачальное значение в начальной клетке

    // ƒобавл€ем начальную клетку в очередь
    pq.push({-value[0][0], {0, 0}});

    // ¬озможные направлени€ движени€ (вправо и вниз)
    int dx[] = {1, 0};
    int dy[] = {0, 1};

    while (!pq.empty()) {
        int d = -pq.top().first; // –ассто€ние до текущей клетки
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        pq.pop();

        // ѕеребираем возможные соседние клетки
        for (int k = 0; k < 2; k++) {
            int nx = x + dx[k];
            int ny = y + dy[k];

            if (nx >= 0 && nx < N && ny >= 0 && ny < M) {
                int new_dist = d + value[nx][ny];
                if (new_dist < dist[nx][ny]) {
                    dist[nx][ny] = new_dist;
                    pq.push({-new_dist, {nx, ny}});
                }
            }
        }
    }

    cout << dist[N-1][M-1] << endl; // ћинимальный вес еды дл€ достижени€ правого нижнего угла

    return 0;
}
